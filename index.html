<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Valentine Doors</title>
  <style>
    :root {
      --bg: #fff7fb;
      --ink: #2b2b2b;
    }
    html, body {
      height: 100%;
      margin: 0;
      background: var(--bg);
      font-family: ui-rounded, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      color: var(--ink);
      overflow: hidden;
      touch-action: manipulation;
    }
    .wrap {
      display: grid;
      place-items: center;
      height: 100%;
      padding: 16px;
      box-sizing: border-box;
      padding-bottom: 130px; /* leave space for mobile controls */
    }
    canvas {
      width: min(900px, 96vw);
      height: auto;
      border-radius: 18px;
      box-shadow: 0 10px 30px rgba(0,0,0,.08);
      background: white;
      touch-action: none; /* allow swipe handling */
    }
    .hint {
      margin-top: 12px;
      font-size: 14px;
      opacity: .75;
      text-align: center;
      line-height: 1.4;
    }
    .hint kbd{
      padding: 2px 6px;
      border-radius: 8px;
      border: 1px solid rgba(0,0,0,.15);
      background: rgba(255,255,255,.8);
      font-size: 12px;
    }

    /* Mobile controls */
    .controls {
      position: fixed;
      left: 0;
      right: 0;
      bottom: 0;
      padding: 12px 14px calc(12px + env(safe-area-inset-bottom));
      display: grid;
      place-items: center;
      pointer-events: none; /* allow clicks only on buttons */
      background: linear-gradient(to top, rgba(255,247,251,.95), rgba(255,247,251,0));
    }

    .dpad {
      pointer-events: auto;
      display: grid;
      grid-template-columns: 64px 64px 64px;
      grid-template-rows: 64px 64px 64px;
      gap: 10px;
      align-items: center;
      justify-items: center;
      user-select: none;
      -webkit-user-select: none;
    }

    .btn {
      width: 64px;
      height: 64px;
      border-radius: 18px;
      border: 2px solid rgba(0,0,0,0.10);
      background: rgba(255,255,255,0.9);
      box-shadow: 0 8px 18px rgba(0,0,0,0.08);
      font-weight: 800;
      font-size: 20px;
      display: grid;
      place-items: center;
      cursor: pointer;
      touch-action: none;
    }
    .btn:active {
      transform: scale(0.97);
    }

    .btn.blank {
      visibility: hidden;
      pointer-events: none;
    }

    /* Hide the D-pad on desktops with a real keyboard */
    @media (hover: hover) and (pointer: fine) {
      .controls { display: none; }
      .wrap { padding-bottom: 16px; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div>
      <canvas id="game" width="900" height="520" aria-label="Valentine Doors Game"></canvas>
      <div class="hint">
        Desktop: Walk with <kbd>‚Üê</kbd><kbd>‚Üë</kbd><kbd>‚Üí</kbd><kbd>‚Üì</kbd>.
        Phone: Use the on-screen arrows or swipe.
      </div>
    </div>
  </div>

  <!-- On-screen D-pad (phones) -->
  <div class="controls" aria-hidden="false">
    <div class="dpad" role="group" aria-label="Movement controls">
      <div class="btn blank"></div>
      <button class="btn" data-dir="up" aria-label="Move up">‚Üë</button>
      <div class="btn blank"></div>

      <button class="btn" data-dir="left" aria-label="Move left">‚Üê</button>
      <div class="btn blank"></div>
      <button class="btn" data-dir="right" aria-label="Move right">‚Üí</button>

      <div class="btn blank"></div>
      <button class="btn" data-dir="down" aria-label="Move down">‚Üì</button>
      <div class="btn blank"></div>
    </div>
  </div>

  <script>
    /***********************
     * CONFIG (edit here)
     ***********************/
    const VALENTINE_NAME = "Sami";
    const QUESTION = `Will you be my valentine, ${VALENTINE_NAME}?`;
    const SUCCESS_MESSAGE = "Laser Wolf dinner on february 14 @7 pm";
    const YES_DOOR_SIDE = "left"; // "left" or "right"

    /***********************
     * CANVAS SETUP
     ***********************/
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    const W = canvas.width;
    const H = canvas.height;

    const STATE = { mode: "question", t: 0 };

    // Keyboard input
    const keys = new Set();
    window.addEventListener("keydown", (e) => {
      const k = e.key;
      if (["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].includes(k)) {
        e.preventDefault();
        keys.add(k);
      }
    }, { passive: false });
    window.addEventListener("keyup", (e) => keys.delete(e.key));

    /***********************
     * Touch input (D-pad hold)
     ***********************/
    const dirToKey = {
      up: "ArrowUp",
      down: "ArrowDown",
      left: "ArrowLeft",
      right: "ArrowRight",
    };

    // Track which pointer is holding which direction, so multi-touch is sane
    const activePointers = new Map(); // pointerId -> keyName

    function pressDir(dir, pointerId) {
      const k = dirToKey[dir];
      if (!k) return;
      keys.add(k);
      if (pointerId != null) activePointers.set(pointerId, k);
    }

    function releasePointer(pointerId) {
      const k = activePointers.get(pointerId);
      if (k) keys.delete(k);
      activePointers.delete(pointerId);
    }

    // Wire up buttons
    document.querySelectorAll(".btn[data-dir]").forEach(btn => {
      btn.addEventListener("pointerdown", (e) => {
        e.preventDefault();
        btn.setPointerCapture(e.pointerId);
        pressDir(btn.dataset.dir, e.pointerId);
      });

      btn.addEventListener("pointerup", (e) => {
        e.preventDefault();
        releasePointer(e.pointerId);
      });

      btn.addEventListener("pointercancel", (e) => {
        e.preventDefault();
        releasePointer(e.pointerId);
      });

      btn.addEventListener("pointerleave", (e) => {
        // If finger slides off, stop that direction
        if (activePointers.has(e.pointerId)) releasePointer(e.pointerId);
      });
    });

    /***********************
     * Touch input (Swipe on canvas)
     * Swipe sets a direction briefly.
     ***********************/
    let swipeStart = null;
    let swipeKey = null;
    let swipeTimer = 0;

    function startSwipe(e) {
      if (STATE.mode !== "question") return;
      const t = (e.changedTouches && e.changedTouches[0]) || e;
      swipeStart = { x: t.clientX, y: t.clientY };
    }

    function endSwipe(e) {
      if (!swipeStart || STATE.mode !== "question") return;
      const t = (e.changedTouches && e.changedTouches[0]) || e;
      const dx = t.clientX - swipeStart.x;
      const dy = t.clientY - swipeStart.y;
      swipeStart = null;

      const dist = Math.hypot(dx, dy);
      if (dist < 18) return; // ignore tiny swipes/taps

      let k;
      if (Math.abs(dx) > Math.abs(dy)) {
        k = dx > 0 ? "ArrowRight" : "ArrowLeft";
      } else {
        k = dy > 0 ? "ArrowDown" : "ArrowUp";
      }

      // Apply swipe direction for a short burst
      if (swipeKey) keys.delete(swipeKey);
      swipeKey = k;
      keys.add(k);
      swipeTimer = 0.22; // seconds
    }

    canvas.addEventListener("touchstart", (e) => { e.preventDefault(); startSwipe(e); }, { passive: false });
    canvas.addEventListener("touchend", (e) => { e.preventDefault(); endSwipe(e); }, { passive: false });

    /***********************
     * OBJECTS
     ***********************/
    function rectsOverlap(a, b) {
      return (
        a.x < b.x + b.w &&
        a.x + a.w > b.x &&
        a.y < b.y + b.h &&
        a.y + a.h > b.y
      );
    }

    const player = {
      x: W/2 - 20,
      y: H - 120,
      w: 40,
      h: 44,
      speed: 220,
      dir: "down",
    };

    const doorY = 125;
    const doorW = 120;
    const doorH = 170;
    const gap = 120;

    const leftDoor = { x: (W/2) - gap/2 - doorW, y: doorY, w: doorW, h: doorH, label: "YES" };
    const rightDoor = { x: (W/2) + gap/2, y: doorY, w: doorW, h: doorH, label: "NO" };

    function yesDoor() { return YES_DOOR_SIDE === "left" ? leftDoor : rightDoor; }
    function noDoor() { return YES_DOOR_SIDE === "left" ? rightDoor : leftDoor; }

    /***********************
     * DRAW HELPERS
     ***********************/
    function roundedRect(x, y, w, h, r) {
      ctx.beginPath();
      ctx.moveTo(x+r, y);
      ctx.arcTo(x+w, y, x+w, y+h, r);
      ctx.arcTo(x+w, y+h, x, y+h, r);
      ctx.arcTo(x, y+h, x, y, r);
      ctx.arcTo(x, y, x+w, y, r);
      ctx.closePath();
    }

    function drawTinyHeart(cx, cy, s) {
      ctx.save();
      ctx.translate(cx, cy);
      ctx.beginPath();
      ctx.moveTo(0, s/4);
      ctx.bezierCurveTo(0, -s/2, -s, -s/2, -s, s/6);
      ctx.bezierCurveTo(-s, s, 0, s*1.1, 0, s*1.6);
      ctx.bezierCurveTo(0, s*1.1, s, s, s, s/6);
      ctx.bezierCurveTo(s, -s/2, 0, -s/2, 0, s/4);
      ctx.closePath();
      ctx.fillStyle = "rgba(255,105,180,0.35)";
      ctx.fill();
      ctx.restore();
    }

    function drawBackgroundQuestion() {
      const g = ctx.createLinearGradient(0, 0, 0, H);
      g.addColorStop(0, "#ffeaf4");
      g.addColorStop(1, "#ffffff");
      ctx.fillStyle = g;
      ctx.fillRect(0, 0, W, H);

      ctx.fillStyle = "#fff0f7";
      ctx.fillRect(0, H-130, W, 130);

      for (let i=0;i<14;i++){
        const x = (i*67 + (STATE.t*12)%67) % W;
        const y = 40 + (i%3)*18;
        drawTinyHeart(x, y, 8);
      }
    }

    function drawBackgroundSuccess() {
      const g = ctx.createLinearGradient(0, 0, W, H);
      g.addColorStop(0, "#ffd6ea");
      g.addColorStop(1, "#fff6fb");
      ctx.fillStyle = g;
      ctx.fillRect(0, 0, W, H);

      const count = 40;
      for (let i=0;i<count;i++){
        const phase = (STATE.t*1.2 + i*0.7);
        const x = (i*23 + phase*40) % (W+60) - 30;
        const y = 70 + (i*37 % 360) + Math.sin(phase)*10;
        drawTinyHeart(x, y, 10 + (i%3)*3);
      }

      ctx.fillStyle = "rgba(255,255,255,0.5)";
      ctx.fillRect(0, H-150, W, 150);
    }

    function drawDoor(door, kind) {
      const isYes = kind === "yes";
      const base = isYes ? "#b9fbc0" : "#ffd6a5";
      const border = isYes ? "#2a9d4b" : "#d17c00";

      ctx.save();
      ctx.shadowColor = "rgba(0,0,0,0.12)";
      ctx.shadowBlur = 10;
      ctx.shadowOffsetY = 4;

      roundedRect(door.x, door.y, door.w, door.h, 18);
      ctx.fillStyle = base;
      ctx.fill();

      ctx.shadowColor = "transparent";
      ctx.lineWidth = 4;
      ctx.strokeStyle = border;
      ctx.stroke();

      roundedRect(door.x+14, door.y+26, door.w-28, door.h-46, 14);
      ctx.fillStyle = "rgba(255,255,255,0.35)";
      ctx.fill();

      ctx.beginPath();
      ctx.arc(door.x + door.w - 28, door.y + door.h/2 + 10, 8, 0, Math.PI*2);
      ctx.fillStyle = "rgba(0,0,0,0.2)";
      ctx.fill();

      ctx.shadowColor = "transparent";
      ctx.font = "700 22px ui-rounded, system-ui";
      ctx.textAlign = "center";
      ctx.fillStyle = border;
      ctx.fillText(door.label, door.x + door.w/2, door.y - 14);

      ctx.restore();
    }

    function drawDog(p) {
      ctx.save();
      ctx.translate(p.x, p.y);

      ctx.fillStyle = "#c28a5b";
      roundedRect(2, 14, p.w-4, p.h-14, 14);
      ctx.fill();

      ctx.beginPath();
      ctx.arc(p.w/2, 14, 18, 0, Math.PI*2);
      ctx.fillStyle = "#d49a6a";
      ctx.fill();

      ctx.beginPath();
      ctx.ellipse(p.w/2 - 14, 10, 7, 11, 0.3, 0, Math.PI*2);
      ctx.ellipse(p.w/2 + 14, 10, 7, 11, -0.3, 0, Math.PI*2);
      ctx.fillStyle = "#b7794c";
      ctx.fill();

      ctx.fillStyle = "#2b2b2b";
      ctx.beginPath();
      ctx.arc(p.w/2 - 6, 13, 2.4, 0, Math.PI*2);
      ctx.arc(p.w/2 + 6, 13, 2.4, 0, Math.PI*2);
      ctx.fill();

      ctx.beginPath();
      ctx.arc(p.w/2, 18, 3.2, 0, Math.PI*2);
      ctx.fillStyle = "#1f1f1f";
      ctx.fill();

      const wag = Math.sin(STATE.t * 10) * 0.4;
      ctx.save();
      ctx.translate(6, 26);
      ctx.rotate(wag);
      ctx.fillStyle = "#b7794c";
      roundedRect(-8, 0, 10, 22, 8);
      ctx.fill();
      ctx.restore();

      ctx.fillStyle = "rgba(0,0,0,0.12)";
      ctx.beginPath();
      ctx.ellipse(14, p.h-4, 8, 4, 0, 0, Math.PI*2);
      ctx.ellipse(p.w-14, p.h-4, 8, 4, 0, 0, Math.PI*2);
      ctx.fill();

      ctx.restore();
    }

    function drawTopText() {
      ctx.save();
      ctx.textAlign = "center";

      roundedRect(W/2 - 310, 18, 620, 62, 18);
      ctx.fillStyle = "rgba(255,255,255,0.75)";
      ctx.fill();
      ctx.lineWidth = 2;
      ctx.strokeStyle = "rgba(0,0,0,0.08)";
      ctx.stroke();

      ctx.font = "800 28px ui-rounded, system-ui";
      ctx.fillStyle = "#2b2b2b";
      ctx.fillText(QUESTION, W/2, 58);

      ctx.restore();
    }

    function drawSuccessText() {
      ctx.save();
      ctx.textAlign = "center";

      roundedRect(W/2 - 320, H/2 - 70, 640, 170, 22);
      ctx.fillStyle = "rgba(255,255,255,0.78)";
      ctx.fill();
      ctx.lineWidth = 2;
      ctx.strokeStyle = "rgba(0,0,0,0.08)";
      ctx.stroke();

      ctx.font = "900 36px ui-rounded, system-ui";
      ctx.fillStyle = "#ff3b8d";
      ctx.fillText("SHE SAID YES üíò", W/2, H/2 - 18);

      ctx.font = "700 22px ui-rounded, system-ui";
      ctx.fillStyle = "#2b2b2b";
      ctx.fillText(SUCCESS_MESSAGE, W/2, H/2 + 26);

      ctx.restore();
    }

    /***********************
     * UPDATE + LOOP
     ***********************/
    let last = performance.now();
    function loop(now) {
      const dt = Math.min(0.033, (now - last) / 1000);
      last = now;
      STATE.t += dt;

      update(dt);
      render();

      requestAnimationFrame(loop);
    }

    function update(dt) {
      // handle swipe burst timer
      if (swipeTimer > 0) {
        swipeTimer -= dt;
        if (swipeTimer <= 0 && swipeKey) {
          keys.delete(swipeKey);
          swipeKey = null;
        }
      }

      if (STATE.mode !== "question") return;

      let vx = 0, vy = 0;
      if (keys.has("ArrowLeft"))  { vx -= 1; player.dir = "left"; }
      if (keys.has("ArrowRight")) { vx += 1; player.dir = "right"; }
      if (keys.has("ArrowUp"))    { vy -= 1; player.dir = "up"; }
      if (keys.has("ArrowDown"))  { vy += 1; player.dir = "down"; }

      if (vx !== 0 && vy !== 0) {
        vx *= 0.7071; vy *= 0.7071;
      }

      player.x += vx * player.speed * dt;
      player.y += vy * player.speed * dt;

      player.x = Math.max(30, Math.min(W - player.w - 30, player.x));
      player.y = Math.max(90, Math.min(H - player.h - 30, player.y));

      const pRect = { x: player.x, y: player.y, w: player.w, h: player.h };
      if (rectsOverlap(pRect, yesDoor())) {
        STATE.mode = "success";
      } else if (rectsOverlap(pRect, noDoor())) {
        // silent no-door, just nudge away slightly
        player.y += 6;
      }
    }

    function render() {
      ctx.clearRect(0,0,W,H);

      if (STATE.mode === "question") {
        drawBackgroundQuestion();
        drawTopText();

        drawDoor(yesDoor(), "yes");
        drawDoor(noDoor(), "no");

        drawDog(player);

        ctx.save();
        ctx.font = "600 16px ui-rounded, system-ui";
        ctx.fillStyle = "rgba(0,0,0,0.45)";
        ctx.textAlign = "center";
        ctx.fillText("Walk to a door.", W/2, H - 18);
        ctx.restore();
      } else {
        drawBackgroundSuccess();
        drawSuccessText();

        const p = { ...player, x: W/2 - player.w/2, y: H - 180 };
        drawDog(p);
      }
    }

    requestAnimationFrame(loop);
  </script>
</body>
</html>
